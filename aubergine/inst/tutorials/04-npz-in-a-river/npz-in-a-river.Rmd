---
title: "Modelling in R: 1D NPZ in a River"
author: "Karline Soetaert and Thomas Petzoldt"
description: "This tutorial explains elements of a 1D Model in a River."
date: "July-2021"
output: 
  learnr::tutorial:
    progressive: true
    allow_skip: true
runtime: shiny_prerendered
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(learnr)
library(ReacTran)
```

## Introduction

The NPZ model implemented in the tutorial before can easily be extended from 0D 
to 1D. Here it is not necessary to chain code together. Instead, state equations 
can be vectorized to solve the system state for all grid cells in parallel. 

To make this efficient, function `ode.1D` "knows" that under normal circumstances,
only adjacent grid cells depend on each other. This makes it possible to
estimate a banded Jacobian numerically and allows an efficient simulation.

As a second tool, function `tran.1D` from package **ReacTran** can be employed
to take care of vertical transport.

... write more

## Exercise

...


## Solution

```{r river-npz, fig.height=8, fig.width=8}
library(ReacTran)

riverNPZ <- function(time, y, parms) {
  with(as.list(parms), {
    N <- y[       1  :   nbox ]
    P <- y[(  nbox+1):(2*nbox)]
    Z <- y[(2*nbox+1):(3*nbox)]

    p_growth  <- r_pgrow * N / (km_n + N) * P
    z_grazing <- r_zgraz * P / (km_p + P) * Z
    z_loss    <- r_zloss * Z

    n_transport <- tran.1D(C=N, C.up=N.up, v=v, dx=Grid)
    p_transport <- tran.1D(C=P, C.up=P.up, v=v, dx=Grid)
    z_transport <- tran.1D(C=Z, C.up=Z.up, v=v, dx=Grid)

    n_import <- n_transport$flux.up   # in [mmol/m2/d]
    n_export <- n_transport$flux.down

    dN_dt <- c_pn * (-p_growth + (1-asseff) * z_grazing + z_loss) + n_transport$dC
    dP_dt <-         p_growth -               z_grazing           + p_transport$dC
    dZ_dt <-                  +     asseff *  z_grazing - z_loss  + z_transport$dC

    list(c(dN_dt, dP_dt, dZ_dt),
         n_import=n_import, n_export=n_export,
         meanN=mean(N), meanP=mean(P), meanZ=mean(Z))
  })
}
parms <- c(
  r_pgrow    = 0.5,   # phytoplankton growth parameter (1/d)
  r_zgraz    = 0.4,   # zooplankton ingestion parameter (1/d)
  r_zloss    = 0.01,  # zooplankton loss parameter (1/d)

  km_n       = 0.5,   # Monod constant of phyto growth on nutrient (mmol/m3)
  km_p       = 100,   # Monod constant of zoo grazing on phyto (mmol/m3)
  c_pn       = 1/106, # stoichiometric conversion from phosporus P to phyto C (P:C)
  asseff     = 0.3,   # assimilation efficiency of zoo (-)

  v          = 10000, # flow velocity (m/d)
  N.up       = 500,   # nutrient (PO4) in inflow (mmolP/m3)
  P.up       = 10,    # algae in inflow (mmolC/m3)
  Z.up       = 1      # zooplankton in inflow (mmolC/m3)
)

# river morphology
Length <- 500e3  # length of the river (m)
nbox   <- 500    # number of 1D grid cells
Grid   <- setup.grid.1D(L = Length, N = nbox)

# Zoo and Phyto as C and Phosphorus P (mol/m3)
N_init  <- rep(500, times=nbox) # mmolP/m3
P_init  <- rep(100, times=nbox) # mmolC/m3
Z_init  <- rep(10,  times=nbox) # mmolC/m3
y_init  <- c(N_init, P_init, Z_init)

## clone the parameter vector and create scenarios
#system.time({
parms2 <- parms1 <- parms

parms["v"] <- 1000  # (m/d)
std0 <- steady.1D(y=y_init, time=0, func=riverNPZ, parms=parms,
                  nspec=3, names=c("N","P","Z"), method="runsteady")

parms1["v"] <- 5000  # m/d
std1 <- steady.1D(y=y_init, time=0, func=riverNPZ, parms=parms1,
                  nspec=3, names=c("N","P","Z"), method="runsteady")

parms2["v"] <- 10000 # m/d
std2 <- steady.1D(y=y_init, time=0, func=riverNPZ, parms=parms2,
                  nspec=3, names=c("N","P","Z"), method="runsteady")

plot(std0, std1, std2, mfrow=c(3,1), grid=Grid$x.mid/1000, lty=1, lwd=2, xlab="km")
#})
```


## A Goody at the end: Parallel execution with `future`

We have seen that computation took a while, and if we go through the script line by
line, we may consider to wait before we enter the next part. Here we can ask: Why not running the simulation in the background or Why not running the three scenarios in parallel on our multiprocessor machine? 

This is indeed possible and R has different mechanisms for this, one intriguingly 
simple is provided by package **future**. In the following, we enclose the
simulations in curly brackets and use the `%<-%` operator instead of the common `<-`.

Before that, we set a `plan` that **R** should run this in multiple sessions.

What does it do? After entering sich a code segment, R gives control back to the user,
and starts simulation in a separate R worker process in the background.
This can then be done for all three scenarios one after each other, because its results (`std0` ... `std2`) are not yet needed for the next step. They are eventually needed "in the future" for the `plot` function, so R does not need to return the results immediately.


```{r river-npz-future, fig.height=8, fig.width=8}
library("future")
system.time({
plan(strategy="multisession")
parms["v"] <- 1000  # (m/d)
std0 %<-% {steady.1D(y=y_init, time=0, func=riverNPZ, parms=parms,
                     nspec=3, names=c("N","P","Z"), method="runsteady")}

parms1["v"] <- 5000  # m/d
std1 %<-% {steady.1D(y=y_init, time=0, func=riverNPZ, parms=parms1,
                     nspec=3, names=c("N","P","Z"), method="runsteady")}

parms2["v"] <- 10000 # m/d
std2 %<-% {steady.1D(y=y_init, time=0, func=riverNPZ, parms=parms2,
                     nspec=3, names=c("N","P","Z"), method="runsteady")}

plot(std0, std1, std2, mfrow=c(3,1), grid=Grid$x.mid/1000, lty=1, lwd=2, xlab="km")
plan(strategy="sequential") # return to the default plan and close the workers
})
```

The normal version took 11s and the "future" version 6s on my PC.


