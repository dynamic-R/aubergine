---
title: "Modelling in R: A Chemostat"
author: "Thomas Petzoldt"
description: "The example shows a chemostat model by example of an autotrophic organisms, where growth is limited by a single nutrient (e.g. phosphorus) via a Monod equation."
date: "July-2021"
bibliography: chemostat.bib
output: 
  learnr::tutorial:
    progressive: true
    allow_skip: true
runtime: shiny_prerendered
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(learnr)
```

## Introduction

The example shows a chemostat model [cf. @Novick1950;@Herbert1956] by example of heterotrophic or autotrophic organisms (bacteria, algae, $P$), where growth is limited by a single nutrient (e.g. phosphorus, $N$) via a Monod equation.

We use here a notation, compatible with the so-called NPZ and NPZD models where $N$ 
is a nutrient (nitrogen or phosphorus), $P$ is phytoplankton, $Z$ zooplankton and optionally
$D$ detritus. Please don't get confused! Here **P** is phytoplankton and not phosphorus, while
the symbol for the nutrient **N** does not necessarily mean that it is nitrogen.

## Implementation

The system is solved numerically with solvers from package **deSolve** [@Soetaert2010a], while equilibria at infinite time are estimated with package **rootSolve** [@Soetaert2009]. The implementation follows the standard formulation of these packages, see package documentation of **deSolve** and **rootSolve**, and @Soetaert2010a or @Soetaert2010c for details. 
The code is written in the **R** programming language for statistical computing [@RCore2018].

```{r, chemostat}
library("deSolve")
library("rootSolve")

chemostat <- function(time, y, parms) {
  with(as.list(c(y, parms)), {
    p_growth <- r_pgrow * N / (km_n + N) * P
    n_import <- d * N0
    n_export <- d * N
    p_export <- d * P
    
    dN_dt   <- n_import - c_pn * p_growth - n_export
    dP_dt   <-                   p_growth - p_export
    list(c(dN_dt, dP_dt), p_growth = p_growth)
   })
}
parms <- c(
  r_pgrow = 0.5,   # phytoplankton growth parameter (1/d)
  km_n    = 1.0,   # half saturation constant, P (mmol/m3)
  c_pn    = 1/106, # stoichiometric conversion from phosporus P to phyto C (P:C ratio)
  d       = 0.1,   # dilution rate 1/d
  N0      = 5      # P in inflow (mmol/m3)
)
times <- seq(0, 40, 0.1)  # simulation time (d)
y  <- c(N = 5, P = 1)     # Nutrient (phosphorus) N and Phytoplankton carbon (mmol/m3)
```

## Dynamic simulation

A dynamic simulation can then be performed by function `ode`, using the default algorithm `lsoda` with automatic integration step size. The result (`out`) is then a matrix-like object of class `deSolve` that is supported by a generic (i.e. object oriented) plot function.

```{r, single, , fig.height=3, fig.width=8}
out <- ode(y, times, chemostat, parms)
plot(out, mfrow=c(1, 3))
```

The plot function allows also to show several scenarios simultanaeously:

```{r, multiple, fig.height=3}
y  <- c(N=5, P=1)
p1 <- p2 <- p3 <- parms
p1["d"] <- 0; p2["d"] <- 0.3; p3["d"] <- 0.5
out  <- ode(y, times, chemostat, parms)
out1 <- ode(y, times, chemostat, p1)
out2 <- ode(y, times, chemostat, p2)
out3 <- ode(y, times, chemostat, p3)

plot(out, out1, out2, out3, which=c("N", "P"))
```

## Steady State

The equilibrium can be aproximated numerically with package **rootSolve**. 
We use a loop here for simplicity, even if list-based approaches (e.g. `lapply`) 
may appear as more elegant for the intermediate and advanced **R** user.


```{r, steadystate, fig.height=3, fig.width=8}
state <- data.frame(
  d   = seq(0.01, 0.5, length.out = 100),
  N = 0,
  P   = 0
)

y <- c(N=0.05, P=0.01)

for (i in 1:nrow(state)) {
  parms["d"] <- state$d[i]
  times <- c(0, Inf)
  out <- runsteady(y, times, chemostat, parms)
  state[i, 2:3] <- out$y
}

par(mfrow = c(1, 3))
plot(N     ~ d, data = state, type = "l")
plot(P     ~ d, data = state, type = "l")
plot(N * P ~ d, data = state, type = "l")
```

## Analytical Solution

The same equilibrium can be reproduced by the analytical solution of chemostat equations.

```{r analytical, fig.height=3, fig.width=8}
# D <- seq(0, 0.6, length.out = 100)
# r_max = 0.5;  kp = 0.5; Y = 106; N0 = 5
# 
# N <- D * kp / (r_max - D)
# N <- ifelse(D > (r_max * N0)/(kp + N0), N0, N)
# 
# P <- Y * (N0 - N)
# 
# par(mfrow=c(1, 3))
# plot(D, N,     type="l")
# plot(D, P,     type="l")
# plot(D, N * P, type="l")
```



## Exercise: a chemostat with NPZ (work in progress)

* To do: make notation consistent to NPZD model

The chemostat equations can serve as a starting point for further extensions, e.g. the production of specific substances in bioreactors, or additional trophical levels. The equations are the fundamental for the description of other technical or non-technical flow-through systems, up to waste water treatment plants, or lakes. Here we want to go a small step in this direction and implement zooplankton as a third state variable and then test its behaviour.


## The model


```{r chemostat-npz}

npz <- function(time, y, parms) {
  with(as.list(c(y, parms)), {
 
    p_growth <- r_pgrow * N / (km_n + N) * P
    
    z_grazing    <- r_zgraz  * P / (km_p + P) * Z
    z_growth     <- asseff * z_grazing
    n_recycling  <- (1 - asseff) * c_pn * z_grazing

    n_import <- d * N0
    n_export <- d * N
    p_export <- d * P
    z_export <- d * Z    
    
    dN_dt   <- n_import - c_pn * p_growth - n_export + n_recycling
    dP_dt   <- p_growth - z_grazing - p_export
    dZ_dt   <- z_growth - z_export
    
    list(c(dN_dt, dP_dt, dZ_dt))
   })
}
parms <- c(
  r_pgrow  = 0.5,   # phytoplankton growth parameter 1/d
  r_zgraz  = 0.4,   # zooplankton grazing parameter 1/d
  asseff   = 0.3,   # zooplankton assimilation efficiency (-)

  km_n = 0.5,   # Monod constant of phyto growth on nutrient (mmol/m3)
  km_p = 100,   # Monod constant of zoo growth on phyto (mmol/m3)

  c_pn       = 1/106, #stoichiometric conversion from phosporus P to phyto C (P:C ratio)

  d  = 0.1,           # dilution rate 1/d
  N0 = 5              # P in inflow (mmol/m3)
)

times <- seq(0, 40, 0.1)        # (d)

# Zoo and Phyto as C and Phosphorus P (mol/m3)
y  <- c(N = 5, P=1, Z = 10)

parms["d"] <- 0.1
out0 <- ode(init, times, npz, parms)
plot(out0, mfrow = c(1, 3))
```

## Scenarios


* scenario 0: equilibrium, algae extinct
* scenario 1: Lotka-Volterra cycle
* scenario 2: equilibrium, zooplankton extinct
* scenario 3: equilibrium, coexistence
* scenario 4: equilibrium, both extinct
* scneario 5: damped oscillation


```{r npz-scenario0, fig.height=3, fig.width=8}
times <- seq(0, 400, 0.1)        # (d)
parms["d"] <- 0.0
out0 <- ode(init, times, npz, parms)
plot(out0, mfrow = c(1, 3))
```

```{r npz-scenario1, fig.height=3, fig.width=8}
parms["d"] <- 0.2
out1 <- ode(init, times, npz, parms)
plot(out1, mfrow=c(1, 3))
```

```{r npz-scenario2, fig.height=3, fig.width=8}
parms["d"] <- 0.07
out2 <- ode(init, times, npz, parms)
plot(out2, mfrow=c(1, 3))
```

```{r npz-scenario3, fig.height=3, fig.width=8}
times <- seq(0, 1000)
parms["d"] <- 0.09
out3 <- ode(init, times, npz, parms)
plot(out3, mfrow=c(1, 3))
```


```{r npz-scenario4, fig.height=3, fig.width=8}
parms["d"] <- 0.5
out4 <- ode(init, times, npz, parms)
plot(out4, mfrow=c(1, 3))
```

```{r npz-damped, fig.height=3, fig.width=8}
# scenario X: damped Lotka-Volterra cycle
parms["d"] <- 0.081
out5 <- ode(init, times, npz, parms)
plot(out5, mfrow=c(1, 3))
```

## References

<div id="refs"></div>

----
